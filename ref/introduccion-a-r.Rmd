---
output: github_document
bibliography: biblio.bib
csl: apa.csl
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_knit$set(root.dir = "..")
knitr::opts_chunk$set(
  echo = TRUE,
  collapse=TRUE,
  fig.path = "../img/"
)
```


<!-- Este .md fue generado a partir del .Rmd homónimo. Edítese el .Rmd -->

# Introducción a R, *simple features* y análisis exploratorio de datos espaciales (ESDA)

## ¿Por qué R?

**En corto**: R cuenta con múltiples herramientas de análisis espacial y geoestadística para crear flujos de trabajo reproducibles.

**En detalle**: Además de sus capacidades para análisis estadísticos avanzados, R cuenta con un "ecosistema" de paquetes para análisis de datos espaciales [muy nutrido](https://cran.r-project.org/web/views/Spatial.html). Igualmente, cuenta con [potentes y versátiles herramientas de representación gráfica](https://www.r-graph-gallery.com/), dispone de un entorno de desarrollo integrado (IDE) orientado a la reproducibilidad y al control de versiones (e.g. [RStudio](https://rstudio.com/)) y, no menos importante, ¡ES LIBRE! Los programas basados en interfaz gráfico difícilmente garantizan reproducibilidad, y no disponen de todas las herramientas de análisis espacial con las que cuenta R.

<figure><img src="../img/diferencias_en_enfasis_software.png"></figure>
Diferencias en énfasis entre software SIG con interfaz gráfico y R. Fuente: @lovelace2019geocomputation


## Introducción a R

### Recursos

Verás a continuación algunas fuentes de referencia sobre los programas y servicios que manejarás.

* Sobre [R](https://www.r-project.org/)
    * [Vídeo corto sobre la historia de R](https://es.coursera.org/lecture/intro-data-science-programacion-estadistica-r/historia-e-introduccion-a-r-alNk0), donde aprenderás algunas características de R y el software libre en general, ventajas y desventajas de R, así como algunas aplicaciones.
    * [Libro R4DS, R for Data Science](https://r4ds.had.co.nz/), una fuente muy completa realizada principalmente por @Wickham2017R, con apoyo de la comunidad R. [Fue traducido recientemente a español como "R para Ciencia de Datos"](https://es.r4ds.hadley.nz/) por la comunidad R de Latinoamérica, con el objetivo hacer R más accesible en la región. Es un buen punto de partida. La organización del libro, que prioriza el aparato gráfico sobre la parte programática, ayuda a mantener la motivación en el aprendizaje de R.
    * [Este es un manual de R](https://cran.r-project.org/doc/contrib/rdebuts_es.pdf) con enfoque orientado a la programación, y es todo un clásico [@paradis2003r].
    * [Esta web](https://oscarperpinan.github.io/R/) es bastante completa para un nivel introductorio a R, y es a la vez un buen lugar de referencia [@perpinan2019intro].
    * [Geocomputation with R](https://geocompr.robinlovelace.net/) [@lovelace2019geocomputation], el cual, como aseguran sus autores, trata sobre **hacer cosas con datos espaciales usando R**, enseñando destrezas como lectura y escrituras de datos espaciales, hacer mapas, modelizar fenómenos geográficos, entre otras.
    * [R-spatial](https://www.r-spatial.org/). Es un sitio web y blog dirigido a personas interesadas en usar R para anlizar datos espaciales y espacio-temporales. Además de publicar entradas periódicas sobre herramientas de análisis espacial con R, el sitio aloja el libro [Spatial Data Science](https://keen-swartz-3146c4.netlify.com/) [@pebesma2019spatial], que explica los conceptos que subyacen a los datos espaciales: puntos, líneas, polígonos, rásters, cubos de datos, entre otros. Aborda también conceptos de mayor nivel, por ejemplo, cómo afectan los atributos y las geometrías en el análisis espacial.
    * La existencia de una diversa y activa comunidad R incentiva a muchos/as usuarios/as a usar este entorno de programación. [A continuación](#twitter) verás algunas cuentas de Twitter, donde podrás observar en vivo una mínima parte de la actividad de la comunidad R. Hay muchas otras cuentas, foros, sitios web e incluso reuniones periódicas donde podrás interactuar con la comunidad. Te animo a descubrirlas.
    * [RStudio](https://www.rstudio.com/). Tanto la página de Wikipedia como [este vídeo](https://www.youtube.com/watch?v=5XeFFoTf2IY) explican muy bien en qué consiste este entorno de desarrollo integrado, además de que hace una breve introducción a qué es R.
* [Git](https://git-scm.com/). Bueno, esta es una larga historia, que parece estar bien resumida en [Wikipedia](https://es.wikipedia.org/wiki/Git). Busca en YouTube, y verás otros aportes. 
* [GitHub](https://github.com/). Se erige como un servicio público para desarrolladores y desarrolladoras. Luce bien explicado [aquí](https://www.deustoformacion.com/blog/programacion-diseno-web/que-es-para-que-sirve-github). Recomiendo también el libro web ["*Happy Git and GitHub for the useR*"](https://happygitwithr.com/) [@bryan2019happy].
* [GitHub Classroom](https://github.com/education/classroom]). En [esta web](https://www.genbeta.com/desarrollo/classroom-for-github-ayudando-a-los-profesores-a-gestionar-los-ejercicios-de-sus-clases) te explican para qué sirve. Con este servicio estoy asignándote trabajo. También te recomiendo que leas  [ésta afirmación](https://github.com/education/classroom#who-is-github-classroom-for) sobre "Who is GitHub classroom for?".
* Foros de ayuda y listas de distribución, entre los que destacan [R-help](https://stat.ethz.ch/mailman/listinfo/r-help), [R-devel](https://stat.ethz.ch/mailman/listinfo/r-devel), [Stackoverflow](https://stackoverflow.com/). Las preguntas deben plantearse con un ejemplo reproducible. Si vas a plantear una, lee antes las guías de publicación. Existe una [lista de distribución de R-help en español](https://stat.ethz.ch/mailman/listinfo/r-help-es), así como de [Stackoverflow en español](https://es.stackoverflow.com/).
* <a name="twitter"></a>Twitter:
    * [The R Foundation](https://twitter.com/_r_foundation)
    * [RStudio](https://twitter.com/rstudio)
    * [RLadies](https://twitter.com/RLadiesGlobal)
    * [We Are R-Ladies](https://twitter.com/WeAreRLadies)
    * [Comunidad R Hispano](https://twitter.com/r_hisp?lang=es)
    * [Hadley Wickham](https://twitter.com/hadleywickham)
    * [Gabriela de Queiroz](https://twitter.com/gdequeiroz)
    * [Jenny Bryan](https://twitter.com/JennyBryan)
    * [R Consortium](https://twitter.com/rconsortium)
    * [UseR! 2020](https://twitter.com/useR2020stl)
    * [UseR! 2019](https://twitter.com/UseR2019_Conf)

### Instalación y ejecución de R y RStudio

* Puedes usar el servidor RStudio habilitado por el profesor. Revisa tu buzón de correo electrónico (también el *spam*), y localiza un mensaje donde te explico los detalles de acceso.

* Si prefieres trabajar en tu propia PC, instala R y RStudio, y los paquetes requeridos en las asignaciones. La guía de instalación varía mucho según el sistema operativo:
    * [R](https://cloud.r-project.org/)
    * [RStudio](https://www.rstudio.com/products/rstudio/download/#download)
* Igualmente, la forma de ejecutar estas aplicaciones dependerá del sistema operativo.
    * En GNU/Linux puedes ejecutar aplicaciones tanto desde el gestor de ventanas como desde el intérprete de línea de órdenes (CLI) o "terminal" (por ejemplo, para ejecutar R, presiona `CRTL+ALT+T`, escribe `R` y presiona `<enter>`).
    * En Windows y MacOS la ejecución se realiza desde el GUI.

### CRAN (Comprehensive R Archive Network)
* [¿Qué es CRAN?](https://cran.r-project.org/doc/FAQ/R-FAQ.html#What-is-CRAN_003f)
* Instalar paquetes: Ejemplo: `install.packages(pkgs = 'sf', dependencies = T)`. Si realizas tus asignaciones en el servidor RStudio habilitado por el profesor, no necesitarás instalar paquetes.

### Ayuda de R

```{r help-in-r, eval=F}
help(package = 'base') #Ayuda sobre un paquete
library(help = 'base') #Documentación sobre un paquete
help(lm) #Ayuda sobre una función
?lm #Ídem
example(lm) #Ejemplo(s) sobre una función
help.search("matrix") #Busca la palabra clave en las ayudas de los paquetes
??matrix #Ídem
```

¡Usa los foros! Si introduces un mensaje de error (preferiblemente en inglés) de R en el buscador de tu preferencia, encontrarás varios punteros a foros con posibles soluciones.

## *Simple features*

### Paquetes

Carguemos los paquetes que necesitaremos en esta introducción.

```{r, warning=F, message=F}
library(sf)
library(raster)
library(rgdal)
library(tidyverse)
library(readxl)
library(tmap)
```

Brevemente, con `sf` crearás y manipularás *simple features*, `raster` te ayudará a manipular y analizar imágenes de dicho modelo, con `rgdal` tendrás varias funciones *wrapper* para trabajar con `gdal`desde R, `tidyverse` carga una colección de paquetes para manipular, limpiar y organizar datos de `data.frame`, `readxl` te permitirá cargar archivos Excel, y con `tmap` crearás mapas y los personalizarás. Busca más información sobre estos paquetes, y comprobarás las múltiples capacidades de R para manipular información espacial.

### Mi primer mapa con *simple features*

El siguiente bloque de código carga las regiones de República Dominicana según la división de 2010, a partir de un archivo GeoPackage que contiene 3 capas (regiones propiamente, provincias y municipios^[De la capa municipios, la geometría correspondiente al municipio "Guayubín" resultó ser no válida y fue arreglada]), originalmente *shapefiles* de la @one2015datos.


```{r regiones}
reg.sf <- st_read(dsn = 'data/divisionRD.gpkg', layer = 'REGCenso2010', quiet = T)
plot(reg.sf)
```

La función `st_read` lee la capa correspondiente del GPKG y la convierte a un `simple features` de tipo `MULTIPOLYGON` (este tipo de objetos los analizaremos más adelante).

Notar que la capa `REGCenso2010`, cuenta con dos campos, por lo que la función `plot` representa a los municipios aplicándoles distintos estilos en función del campo representado.  Las regiones fueron coloreadas en función de los campos `REG` y `TOPONIMIA`. Probemos una visualización cuantitativa. Crearemos un campo de área mediante la función `st_area` (en m<sup>2</sup>, que son las unidades del CRS, que es EPSG:32619), representaremos el objeto `reg.sf` usando sólo dicho campo (`reg.sf['area']`) y le aplicaremos estilos al mapa en función de éste.

```{r regiones2, results='asis'}
reg.sf$area <- st_area(reg.sf)
plot(reg.sf['area'])
```

>El mapa anterior es mejorable en muchos aspectos. En este mismo tutorial, probarás formas de diseñar mapas estilizados.

El bloque de código a continuación carga la capa de municipios desde el GPKG y la representa. Al igual que con la capa regional, dado que tiene múltiples campos (en este caso, 3 adicionales), la función `plot` representa a los municipios aplicándoles distintos estilos en función del campo representado.

```{r municipios}
mun.sf <- st_read(dsn = 'data/divisionRD.gpkg', layer = 'MUNCenso2010', quiet = T)
plot(mun.sf)
mun.sf$area <- st_area(mun.sf)
plot(mun.sf['area'])
```

### ¿Qué son *simple features*?

Veamos lo básico sobre el modelo de datos *simple features*. Se trata de un estándar abierto y jerárquico del Open Geospatial Consortium (organización sin ánimo de lucro que agrupa a entidades públicas y privadas comprometida con este tipo de estándares). Mediante *simple features* se representan al menos 17 tipos de geometrías (sólo admite vectoriales), de las que 7 son ampliamente usadas en análisis espacial (ver figura a continuación).

<figure><img src="../img/tipos_geometria_sf.png"></figure>
Tipos de *simple features* admitidos por el paquete `sf`. Fuente: @lovelace2019geocomputation

Por ejemplo, exploremos el objeto `mun.sf` en la consola; basta con escribir su nombre para obtener un resumen que muestra el tipo de geometría y otras características espaciales, como el sistema de referencia espacial (CRS). A continuación, mostrará los atributos de los primeros 10 objetos (explicados más adelante).

```{r}
mun.sf
```

Nos informa que se trata de un `Simple feature collection with 155 features and 6 fields` de tipo `MULTIPOLYGON` con dimensiones `XY` y una extensión mostrada en la línea `bbox`. Igualmente, nos indica que el CRS es EPSG:32619, o WGS84 UTM zona 19.

El modelo de datos de los *simple features* se basa en estructuras similares a las que usan bases de datos espaciales, como PostGIS, favoreciendo así la interoperabilidad. Otras ventajas que se señalan en su favor son: mejor rendimiento para lectura, escritura y representación ("ploteado") de datos espaciales, maneja objetos tipo `data.frame` (ver más abajo) y, no menos importante, las operaciones geométricas y de atributos se pueden realizar mediante tuberías (*pipelines*) de la colección `tidyverse`.

Los *simple features* se integran en R mediante el paquete `sf` [@pebesma2018simple]. El paquete `sf` supera significativamente a su predecesor, `sp` en eficiencia y facilidad de uso. Asimismo, `sf` depende de otros paquetes de R muy eficientes, y también de paquetes externos mantenidos por una comunidad muy amplia (como GDAL, GEOS y PROJ). A continuación se muestra un gráfico de las dependencias.

<figure><img src="../img/sf_y_sus_dependencias.png"></figure>
El paquete `sf` y sus dependencias. Las flechas sólidas indican dependencia fuerte; las de trazo discontinuo, dependencia débil. Fuente: @pebesma2019spatial

Los *simple features* se almacenan en...tablas. Sí, sí, tablas, denominadas `data.frames` en R, que en el caso concreto serían "tablas espaciales" (*spatial data frames*). Exploremos la estructura del objeto `mun.sf` mediante la función `str`, la cual lo muestra como `Classes 'sf' and data.frame: 10 obs. of 4 variables` (155 observaciones o geometrías, que en este caso son municipios dominicanos, y 4 variables o atributos).

```{r}
str(mun.sf)
```

Al tratarse de un `data.frame`, los análisis estadísticos se ejecutan de manera fluida y sin necesidad de extraer los datos a archivos externos. Así, por ejemplo, la función `summary`, muy empleada en R para obtener estadísticos descriptivos, devuelve estadísticos de todas las columnas de atributos (incluida la de geometría, nombrada como `geom` en este caso):

```{r}
summary(mun.sf)
```

La función `summary` actúa igualmente sobre una columna filtrada desde el objeto `reg.sf`, en este caso `area`.

```{r}
summary(mun.sf['area'])
```

>Nota que la columna `geom` se mantiene en el resumen, puesto que siempre acompaña al objeto a menos que le indiquemos lo contrario (*sticky column*).

### *Simple features*, de abajo a arriba

Normalmente, los datos espaciales se crean en aplicaciones con GUI (e.g. QGIS), o los obtienes de terceros. Sin embargo, para fines didácticos, crearemos algunos objetos conteniendo los tipos de geometrías básicos en la forma de *simple feature geometries* (`sfg`) en el siguiente bloque de código. Las crearemos utilizando **coordenadas geográficas**, aunque no podremos definir un CRS, puesto que la clase `sfg` no admite dicha funcionalidad. Las funciones que utilizaremos para cada geometría serán punto `st_point`, línea `st_linestring` y polígono `st_polygon`.

```{r geoms, out.width=c('33%', '33%', '33%'), fig.show='hold'}
pto.sfg <- st_point(c(-70.3, 19))
pto.sfg
plot(pto.sfg, col = 'red'); box()
matrizlin <- rbind(c(-71.5, 18), c(-71.2, 18),
                   c(-71.2, 18.4), c(-71.5, 18.4))
matrizlin
lin.sfg <- st_linestring(matrizlin)
lin.sfg
plot(lin.sfg, col = 'red'); box()
matrizpol <- list(
  rbind(c(-70.7, 18.6), c(-70.4, 18.6),
        c(-70.4, 18.9), c(-70.7, 18.9),
        c(-70.7, 18.6)))
pol.sfg <- st_polygon(matrizpol)
pol.sfg
plot(pol.sfg, col = 'red'); box()
```

Si combinamos varios puntos generamos un elemento multipunto (*multipoint*). Lo mismo aplica para las líneas (multilínea, *multilinestring*) y los polígonos (multipolígono, *multipolygon*). El siguiente bloque de código muestra cómo crearlos.

```{r geomsm, out.width=c('33%', '33%', '33%'), fig.show='hold'}
mpto.sfg <- st_multipoint(rbind(c(-70.3, 19), c(-70.4, 19), c(-70.4, 19.1), c(-70.3, 19.1)))
mpto.sfg
plot(mpto.sfg, col = 'red'); box()
matrizmlin <- list(rbind(c(-71.5, 18), c(-71.2, 18), c(-71.2, 18.4), c(-71.5, 18.4)),
                  rbind(c(-70.9, 18), c(-70.5, 18), c(-70.7, 18.4)))
matrizmlin
mlin.sfg <- st_multilinestring(matrizmlin)
mlin.sfg
plot(mlin.sfg, col = 'red'); box()
matrizmpol <- list(
  list(rbind(c(-70.7, 18.6), c(-70.4, 18.6), c(-70.4, 18.9), c(-70.7, 18.9), c(-70.7, 18.6))),
  list(rbind(c(-70, 18.6), c(-70.3, 18.6), c(-70.2, 18.9), c(-70, 18.6)))
)
mpol.sfg <- st_multipolygon(matrizmpol)
mpol.sfg
plot(mpol.sfg, col = 'red'); box()
```

Finalmente, combinaremos varios elementos en una colección, para lo cual usaremos los elementos creados anteriormente.

```{r colec, out.width=c('50%', '50%'), fig.show='hold'}
# colec <- c(pto, lin, pol)
colec1.sfg <- st_geometrycollection(list(pto.sfg, lin.sfg, pol.sfg))
plot(colec1.sfg, col = 'red'); box()
colec2.sfg <- st_geometrycollection(list(mpto.sfg, mlin.sfg, mpol.sfg))
plot(colec2.sfg, col = 'red'); box()
```

Recordemos que, hasta este punto, hemos creado elementos basados en geometrías simples (*simple feature geometries*, `sfg`). Un objeto `sfg` contiene sólo un elemento, que puede ser sencillo, multi\* o una colección. Además, aunque las `sfg` se construyen usando coordenadas, éstas no cuentan con sistema de referencia espacial (CRS). La *simple feature column* (`sfc`), al ser una lista, permite alojar varios elementos y también admite la definición de CRS. La `sfc` es importante porque representa la columna geométrica de un *simple feature* (`sf`), por lo que debemos reconocerla para comprender el modelo de un `sf`. Generaremos una `sfc` a partir de algunos de los `sfg` del objeto `pto.sfg` creado anteriormente (se podrían utilizar los otros igualmente, o combinarlos), y no asignaremos por el momento CRS alguno.

```{r ptosfc}
pto.sfc <- st_sfc(pto.sfg)
pto.sfc
plot(pto.sfc, col = 'red'); box()
```

Aunque la representación gráfica de `pto.sfc` es idéntica a la de su homólogo `pto.sfg`, la diferencia radica en la clase del objeto.

```{r}
class(pto.sfg)
class(pto.sfc)
```

Ahora creemos `sfc` de geometrías basadas en línea y polígono,

```{r linpolsfc, out.width=c('50%', '50%'), fig.show='hold'}
lin.sfc <- st_sfc(lin.sfg)
lin.sfc
plot(lin.sfc, col = 'red'); box()
pol.sfc <- st_sfc(pol.sfg)
pol.sfc
plot(pol.sfc, col = 'red'); box()
mpol.sfc <- st_sfc(mpol.sfg)
mpol.sfc
plot(mpol.sfc, col = 'red'); box()
colec1.sfc <- st_sfc(colec1.sfg)
colec1.sfc
plot(colec1.sfc, col = 'red'); box()
```
Los dos de arriba representan `sfc` de líneas y polígonos, respectivamente. En la franja inferior: izquierda multipolígono, derecha colección.

En el resumen de cada objeto podemos notar que no se ha definido ningún CRS. En cualquier caso, para consultar el CRS de cualquier `sfc` utilizamos la función `st_crs`.

```{r}
st_crs(pto.sfc)
```

Todas las geometrías dentro de una `sfc` deben tener el mismo CRS. Podemos definir el CRS de un objeto al crear la `sfc`, o alternativamente lo definimos luego de creado el objeto.

```{r}
#Al crear el objeto, argumento crs de la función st_sfc
pto.sfc <- st_sfc(pto.sfg, crs = 4326)
pto.sfc
#Alternativamente, usando la función st_crs()
st_crs(lin.sfc) <- 4326
lin.sfc
#También admite cadenas de texto proj4string:
st_crs(pol.sfc) <- '+proj=longlat +datum=WGS84 +no_defs'
pol.sfc
```

Finalmente, construyamos un *simple feature* `sf`. Disponemos de una columna geométrica pero necesitamos atributos. Por lo tanto, primero que crearemos atributos y luego `sf`.

```{r}
#Primero el atributo
pto.atr <- data.frame(nombre='pto')
#Luego creamos el sf
pto.sf <- st_sf(pto.atr, geometry = pto.sfc)
```

¿Cómo se ve el proceso si lo desarrollamos desde cero? Primero creemos la geometría para el punto, luego la columna geométrica, luego los atributos y finalmente el *simple feature*.

```{r}
#Geometría simple
pto.sfg <- st_point(c(-70.3, 19))
#Columna de geometría simple
pto.sfc <- st_sfc(pto.sfg, crs = 4326)
#Atributo
pto.atr <- data.frame(nombre='Mi punto')
pto.atr##Sólo un objeto, por lo tanto, sólo un atributo
#Simple feature
pto.sf <- st_sf(pto.atr, geometry = pto.sfc)
pto.sf
#La clase es la misma que para mun.sf
class(pto.sf)
class(mun.sf)
```

Creemos `sf` a partir de la colección `pto.sfc`, `lin.sfc` y `pol.sfc`. Necesitaremos crearles atributos y generar el `sf`.

```{r}
lin.sfc
lin.atr <- data.frame(nombre = 'Mi línea')
lin.sf <- st_sf(lin.atr, lin.sfc)
lin.sf
pol.sfc
pol.atr <- data.frame(nombre = 'Mi polígono')
pol.sf <- st_sf(pol.atr, pol.sfc)
pol.sf
```

Finalmente, representemos `pto.sfc`, `lin.sfc` y `pol.sfc` sobre el mapa de municipios de RD. Para fines de consistencia, transformaremos `mun.sf` al CRS EPSG:4326, generando el objeto `mun.sf.ll`, el cual será el mapa de fondo (se podría realizar la operación contraria, es decir, convertir `pto.sfc`, `lin.sfc` y `pol.sfc` a EPSG:32619, pero sería más trabajoso). Para la representación utilizaremos el paquete `tmap`, el cual requiere, como mínimo, un objeto fuente y, posteriormente, uno o varios elementos o capas de símbolos. Así, mediante la función `tm_shape`, se especifica el objeto que contiene la geometría, y las funciones `tm_dots`, `tm_lines`, `tm_borders` y `tm_fill` (entre otras) definen cómo se representan las geometrías.

```{r munptlinpol}
mun.sf.ll <- st_transform(mun.sf, crs = 4326) #Transformación a EPSG:4326
tmap_options(max.categories = 155) #Aumentando el máx. número de categorías para tmap
tm_shape(mun.sf.ll) + tm_fill('TOPONIMIA', legend.show = F) +  tm_borders('grey') +
  tm_shape(shp = pto.sf) + tm_dots('black', size = 0.5) +
  tm_shape(shp = lin.sf) + tm_lines(col='black') +
  tm_shape(shp = pol.sf) + tm_fill(col='black')
```





## Análisis exploratorio de datos espaciales (ESDA)

```{r, eval=F}
pop.mun <- read_xls('pop_adm3.xls')
pop.mun
nrow(pop.mun)
pop.mun <- pop.mun %>%
  mutate(ENLACE = ifelse(
    nchar(Code)==5,
    paste0('0', Code),
    Code)
  )
match(mun.sf$ENLACE, pop.mun$ENLACE)

mun.sf.sex <- mun.sf %>% 
  inner_join(pop.mun) %>% 
  select(Hombres, Mujeres, TOPONIMIA) %>% 
  mutate(Total=Hombres+Mujeres)
plot(mun.sf.sex, breaks = 'jenks')
pop.mun.hom <- plot(mun.sf.sex['Hombres'], breaks = 'jenks')

dev.new()
mun.sf.sex %>%
  select(-TOPONIMIA) %>% 
  gather(variable, value, -geometry) %>%
  ggplot(aes(fill=value)) +
  geom_sf() +
  facet_wrap(~variable)

p1 <- tm_shape(mun.sf.sex) +
  tm_fill(col = "Hombres", style = 'jenks') +
  tm_borders()
p2 <- tm_shape(mun.sf.sex) +
  tm_fill(col = "Mujeres", style = 'jenks') +
  tm_borders()
p3 <- tm_shape(mun.sf.sex) +
  tm_fill(col = "Total", style = 'jenks') +
  tm_borders()
tmap_arrange(p1, p2, p3)

p1text <- tm_shape(mun.sf.sex) +
  tm_fill(col = "Hombres", style = 'jenks') +
  tm_borders() +
  tm_text('TOPONIMIA', size = 0.4)
tmap_arrange(p1text)
```



## Conclusión

Conociste las herramientas básicas para realizar un EDA ágilmente y generando gráficos informativos. **El EDA es un paso imprescindible en cualquier investigación**, así que, ya que no te lo podrás saltar, es necesario que practiques con los datos de ejemplo mostrados aquí, o con los tuyos propiamente.

Aunque los paquetes de análisis de datos ecológicos no están "saborizados" al estilo `tidyverse`, al menos el EDA lo podrás realizar utilizando tuberías de esta potente colección de paquetes. Conocerás más herramientas de `tidyverse` en el siguiente capítulo de esta novela.

## Situaciones comunes
* R es sensible a las mayúsculas. No es lo mismo `Mi_objeto` que `mi_objeto`.
* *"En RStudio, ¿Qué atajo de teclado es que usan para poner el operador de asignación ` <- `?"* Debería funcionarte `ALT+-`, pero recuerda, sólo lo podrás usar en RStudio.
* *"¿Y el pipe ` %>% `?"* `CTRL+SHIFT+M`.
* Más atajos de teclado de RStudio: `ALT+SHIFT+K`.
* *"Me quedé trancá' en la consola de R con un signo de `+`. ¿Qué hago pa' salir de eso?"* Suele resolverse presionando la tecla `Escape` (`Esc`). Lee [este texto](https://support.rstudio.com/hc/en-us/community/posts/200792676-stuck-on-).


## Referencias

